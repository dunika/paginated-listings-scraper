{"version":3,"sources":["debug.js","extract-data.js","scrape-page.js","scrape-listing.js","index.js"],"names":["getNextPageUrl","nextPageSelector","$","url","depth","element","href","attr","nextPageUrl","URL","error","origin","buildExtractText","selector","parent","find","text","trim","buildExtractData","selectors","data","Bluebird","reduce","results","key","extract","cheerio","load","html","result","Error","message","withTerminate","terminate","state","hasFinished","hasPrinted","extractWithTerminate","buildDataSelectorExtractor","dataSelector","rest","extractListingData","elements","parentSelector","filter","length","nextRequestOptions","extractor","parents","map","index","get","extractedData","Boolean","scrapePage","getPage","loadCheerio","requestOptions","body","request","uri","resolvedUrl","extractData","scrapeListing","getListings","otherOptions","maximumDepth","getListing","requestUrl","nextData","shouldReturnDataOnError","options"],"mappings":";AAEe,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAFf,IAAA,EAAA,QAAA,SAEe,EAAA,EAAA,GAAA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAAA,QAAA,SAAA,EAAM,EAAA,SAAA;;ACqHd,aAAA,OAAA,eAAA,QAAA,aAAA,CAAA,OAAA,IAAA,QAAA,mBAAA,QAAA,sBAAA,EAAA,IAAA,EAAA,QAAA,iDAAA,EAAA,EAAA,GAAA,EAAA,QAAA,iCAAA,EAAA,EAAA,GAAA,EAAA,QAAA,wCAAA,EAAA,EAAA,GAAA,EAAA,QAAA,0CAAA,EAAA,EAAA,GAAA,EAAA,QAAA,iBAAA,EAAA,EAAA,GAAA,EAAA,QAAA,qBAAA,EAAA,EAAA,GAvHP,EAAA,QAAA,OACA,EAAA,QAAA,YAsHO,EAAA,EAAA,GArHP,EAAA,QAAA,WAqHO,EAAA,EAAA,GAlHP,EAAA,QAAA,WAkHO,EAAA,EAAA,GAAA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GAzGP,MAAMA,EAAiB,SAAwBC,EAAkBC,EAAGC,EAAKC,GACnE,IAAA,EAAWH,EAAAA,SAAAA,GACNA,OAAAA,EAAiB,CAAEC,EAAAA,EAAGE,MAAAA,EAAOD,IAAAA,IAGhCE,MAAAA,EAAUH,EAAED,GACd,IAACI,EAEI,OADA,EAAA,EAAA,mEAAyDJ,KACzD,KAGHK,MAAAA,EAAOD,EAAQE,KAAK,QACtB,IAACD,EACI,OAAA,KAGL,IACIE,MAAAA,EAAc,IAAIC,EAAJ,IAAQH,GAAMA,KAE3BE,OADA,EAAA,EAAA,sCAA4BL,KAC5BK,EACP,MAAOE,GACD,MAAA,OAAEC,GAAW,IAAIF,EAAJ,IAAQN,GACnB,SAAEQ,IAASL,MAKjBM,EAAmBC,GAAY,EAAGX,EAAAA,EAAGY,OAAAA,MAElCT,OADSS,EAASA,EAAOC,KAAKF,GAAYX,EAAEW,IACpCG,OAAOC,QAGXC,EAAmBC,QAAAA,iBAAAA,CAAAA,GAAAA,MAAa,IAAA,GAAA,EAAA,EAAA,SAAA,WAAO,OAAA,EAAA,KAAA,EAAA,IAGlDhB,IAEI,IACIiB,MAAAA,QAAaC,EAASC,QAAAA,QAC1B,EAAeH,EAAAA,SAAAA,IACf,GAAA,EAAA,EAAA,SAAA,UAAOI,GAAUC,EAAKX,IACdY,MAAAA,GAAU,EAAWZ,EAAAA,SAAAA,GAAYA,EAAWD,EAAiBC,GAC7DX,EAAIwB,EAAQC,QAAAA,KAAKC,GACnB,IACIC,MAAAA,QAAeJ,EAAQ,CAAEvB,EAAAA,EAAGY,OAAAA,EAAQX,IAAAA,IAErCoB,OAAAA,EAAAA,EAAAA,SAAAA,GAAAA,EADL,CAEGC,CAAAA,GAAMK,IAET,MAAOnB,GACD,MAAA,IAAIoB,SAASN,KAAOd,EAAMqB,cAZnB,SAAA,EAAA,GAAA,OAAA,EAAA,MAAA,KAAA,aAcd,IAEE,OAAA,EAAOX,EAAAA,SAAAA,GACd,MAAOV,GAED,MADC,EAAA,EAAA,+BAAqBA,EAAMqB,WAC5B,IAAID,2BAA2B3B,YACjCO,EAAMqB,iBApBS,IAEjB,IAR0B,OAAA,SAAA,GAAA,OAAA,EAAA,MAAA,KAAA,aAAAZ,IAqC1Ba,EAAgB,CAACP,EAASQ,KACxBC,MAAAA,EAAQ,CAAEC,aAAa,EAAOC,YAAY,GAChD,MAAA,MAAO,IAAA,GAAA,EAAA,EAAA,SAAA,WAAoC,KAAER,EAAF,OAAQd,EAAR,IAAgBX,IACnDD,MAAAA,EAAIwB,EAAQC,QAAAA,KAAKC,GAEnBM,OADEC,EAAAA,YAAcF,EAAUnB,EAAQZ,GAClCgC,EAAMC,aACHD,EAAME,cACH,EAAA,EAAA,SAAA,4BACAA,EAAAA,YAAa,GAEd,YAEUX,EAAQ,CAAEG,KAAAA,EAAMd,OAAAA,EAAQX,IAAAA,MAVvBkC,OAAAA,SAAtB,GAAA,OAAA,EAAA,MAAA,KAAA,aAAA,IAeIC,EAA6BC,GAAuC,IAAtB,IAAA,KAAEX,GAAoB,EAAXY,GAAW,EAAA,EAAA,SAAA,EAAA,CAAA,SAClEtC,MAAAA,EAAIwB,EAAQC,QAAAA,KAAKC,GAChBW,OAAAA,GAAerC,EAAAA,EAAAA,SAAAA,CAAAA,EAAAA,GAAMsC,KAiBjBC,EAAAA,QAAAA,mBAAAA,MAAqB,IAAA,GAAA,EAAA,EAAA,SAAA,WAAkC,aAAA,EAAA,MAAA,EAAA,OAAA,EAAA,KAAA,EAAA,iBAAA,EAAA,mBAAA,EAAA,eAAA,EAAA,UAAA,EAAA,IASlEtC,IAEMD,MAAAA,EAAIwB,EAAQC,QAAAA,KAAKC,GACjBc,EAAWxC,EAAEyC,GAAgBC,OAAQA,GAAS,WAAM,OAAA,IAEtD,IAACF,EAASG,OAEL,OADA,EAAA,EAAA,uCAA6BF,KAC7B,CACC,KAAA,KACO3C,YAAAA,EAAeC,EAAkBC,EAAGC,EAAKC,GAClC0C,mBAAAA,GAAsBA,EAAmB5C,EAAGC,EAAKC,IAGnE2C,MAAAA,GAAY,EAAWR,EAAAA,SAAAA,GACzBD,EAA2BC,GAC3BrB,EAAiBqB,GAEfd,EAAUQ,EAAYD,EAAce,EAAWd,GAAac,EAE5DC,EAAUN,EAASO,IAAI,SAACC,EAAO7C,GAAYH,OAAAA,EAAEG,KAAU8C,MAEvD/B,QAAaC,EAAS4B,QAAAA,IAAID,GAAS,GAAA,EAAA,EAAA,SAAA,UAAOlC,GAMvCsC,aALqB3B,EAAQ,CAAA,KAAA,EAAA,OAAA,EAGlCtB,IAAAA,MAJe,SAAA,GAAA,OAAA,EAAA,MAAA,KAAA,cAOhByC,OAAOS,SAPS,IAAsB,EAgBlC,MAAA,CAAA,KAAA,EAAA,YANajC,EAAKyB,SAAWH,EAASG,OAAS7C,EACpDC,EACAC,EACAC,GACE,KAKkB2C,mBAAAA,GAAsBA,EAAmB3C,EAAKD,EAAGE,MAjDxBqC,OAAAA,SAApC,GAAA,OAAA,EAAA,MAAA,KAAA,aAAAA;;AC/FiBa,aAAAA,OAAAA,eAAAA,QAAAA,aAAAA,CAAAA,OAAAA,IAAAA,QAAAA,aAAAA,EAAAA,IAAAA,EAAAA,QAAAA,iCAAAA,EAAAA,EAAAA,GAAAA,EAAAA,QAAAA,iDAAAA,EAAAA,EAAAA,GAAAA,EAAAA,QAAAA,0CAAAA,EAAAA,EAAAA,GAxB9B,EAAA,QAAA,0BAwB8BA,EAAAA,EAAAA,GAvB9B,EAAA,QAAA,WAuB8BA,EAAAA,EAAAA,GArB9B,EAAA,QAAA,kBAqB8BA,SAAAA,EAAAA,GAAAA,OAAAA,GAAAA,EAAAA,WAAAA,EAAAA,CAAAA,QAAAA,GAnBvB,MAAMC,EAAAA,MAAU,IAAA,GAAA,EAAA,EAAA,SAAA,UAAOpD,EAAK,EAAqC,IAArC,IAAA,YAAEqD,GAA0C,EAA1BC,GAA0B,EAAA,EAAA,SAAA,EAAA,CAAA,gBACzE,IACI,MAAEC,KAAM9B,EAAM+B,SAAWC,KAAOtD,KAAMuD,WAA0B,EAAA,EAAA,UAAA,EAAA,EAAA,SAAA,CAC3C,yBAAA,EACpB1D,IAAAA,GACFsD,IAEDD,GAAAA,EAAa,CAER,MAAA,CAAEtD,EADCwB,EAAQC,QAAAA,KAAKC,GACXA,KAAAA,EAAMiC,YAAAA,GAEb,MAAA,CAAEjC,KAAAA,EAAMiC,YAAAA,GACf,MAAOnD,GACD,MAAA,IAAIoB,wBAAwB3B,YAC9BO,EAAMqB,oBAdD,OAAA,SAAA,GAAA,OAAA,EAAA,MAAA,KAAA,aAAAwB,GAmBiBD,QAAAA,QAAAA,EAAAA,QAAAA,QAAAA,MAAf,IAAA,GAAA,EAAA,EAAA,SAAA,WAA0B,IAAA,EAAA,UAAA,EAAA,eAGvCG,IAEM,MAAA,KAAE7B,EAAF,YAAQiC,EAAR,EAAqB3D,SAAYqD,EAAQpD,GAAUsD,EAAAA,EAAAA,SAAAA,GAAAA,EAAgBD,CAAAA,aAAa,KAClF,IAAC5B,EACG,MAAA,IAAIE,wBAAwB+B,KAE9BC,MAAAA,GAAc,EAAiB3C,EAAAA,kBAAAA,GAQ9BiC,aAPqBU,EAAY,CAAA,EAAA,EAAA,KAAA,EAAA,UAAA,EAIjCD,IAAAA,MAdqBP,OAAAA,SAAAA,GAAAA,OAAAA,EAAAA,MAAAA,KAAAA,aAAAA;;ACwCAS,aAAAA,OAAAA,eAAAA,QAAAA,aAAAA,CAAAA,OAAAA,IAAAA,IAAAA,EAAAA,QAAAA,iCAAAA,EAAAA,EAAAA,GAAAA,EAAAA,QAAAA,0CAAAA,EAAAA,EAAAA,GAAAA,EAAAA,QAAAA,iDAAAA,EAAAA,EAAAA,GAAAA,EAAAA,QAAAA,wBAAAA,EAAAA,EAAAA,GAAAA,EAAAA,QAAAA,sBAAAA,EAAAA,EAAAA,GA9D9B,EAAA,QAAA,iBACA,EAAA,QAAA,kBACA,EAAA,QAAA,WA4D8BA,EAAAA,EAAAA,GAAAA,SAAAA,EAAAA,GAAAA,OAAAA,GAAAA,EAAAA,WAAAA,EAAAA,CAAAA,QAAAA,GAjD9B,SAASC,EAMN,GANkB,IAAA,aAAA,EAAA,IAAA,EAAA,wBAGO,GAAA,EAHP,UAInB/B,GAEC,EADEgC,GACF,EAAA,EAAA,SAAA,EAAA,CAAA,eAAA,MAAA,0BAAA,cACG,KAAC,EAASC,EAAAA,SAAAA,MAAkB,EAAWjC,EAAAA,SAAAA,GACnCH,MAAAA,MAAM,kEAGRqC,MAAAA,GAAa,GAAA,EAAA,EAAA,SAAA,UAAOC,EAAYX,GAAgB,MAAErD,EAAQ,GAAM,IAChE,IAAA,EAAS8D,EAAAA,SAAAA,IAAiB9D,EAAQ8D,EAE7B,OADA,EAAA,EAAA,mCAAyB9D,KACzB,IAEF,EAAA,EAAA,gCAAsBA,KACzB,IACI,MAAA,KAAEwB,SAAe,EAAQwC,EAAAA,SAAAA,EAAYX,IAEzBX,eAAAA,EADZ,YAAA,EAAA,KAGJ1B,SACQ,EAAqBhB,EAAAA,qBAAAA,EAAAA,EAAAA,SAAAA,CAAAA,MAAAA,EAAOwB,KAAAA,EAAMK,UAAAA,EAAW9B,IAAAA,GAAQ8D,IAE3DzD,GAAAA,GAAesC,EAAoB,CAC/BuB,MAAAA,QAAiBF,EAAW3D,EAAasC,EAAoB,CAAE1C,MAAOA,EAAQ,IAC7E,MAAA,IAAIgB,GAAQA,KAASiD,GAEvBjD,OAAAA,EACP,MAAOV,GAEH4D,IADG,EAAA,EAAA,mBAAS5D,EAAMqB,WAClBuC,EACK,MAAA,GAEH,MAAA,IAAIxC,MAAMpB,MAxBd,SAAA,EAAA,GAAA,OAAA,EAAA,MAAA,KAAA,aAAAyD,IAAa,EA2BZA,OAAAA,EAWqBJ,QAAAA,QAAAA,MAAf,IAAA,GAAA,EAAA,EAAA,SAAA,UAA6BQ,GACtC,IACI,MAAA,IAAEpE,EAAF,eAAOsD,GAAoCc,EAAjBN,GAAiBM,EAAAA,EAAAA,SAAAA,EAAjD,CAAA,MAAA,mBACMH,EAAajE,GAAOsD,EAAetD,IACnCiB,QAAa4C,GAAcI,EAAAA,EAAAA,SAAAA,CAAAA,WAAAA,GAAeH,GAA7BD,CAA6CI,EAAYX,GAMrErC,OALFA,GAGI,EAAA,EAAA,0BAAgBA,EAAKyB,mBAFtB,EAAA,EAAA,SAAA,iBAIDzB,EACP,MAAOV,GAED,MADC,EAAA,EAAA,mBAASA,EAAMqB,WAChB,IAAID,MAAMpB,MAbUqD,OAAAA,SAAAA,GAAAA,OAAAA,EAAAA,MAAAA,KAAAA,aAAAA;;ACzD5BR,aAAAA,OAAAA,eAAAA,QAAAA,aAAAA,CAAAA,OAAAA,IAAAA,QAAAA,QAAAA,QAAAA,gBAAAA,EAPF,IAAA,EAAA,QAAA,oBAOEA,EAAAA,EAAAA,GANF,EAAA,QAAA,iBAMEA,EAAAA,EAAAA,GAAAA,SAAAA,EAAAA,GAAAA,OAAAA,GAAAA,EAAAA,WAAAA,EAAAA,CAAAA,QAAAA,GAJaQ,QAAAA,QAAAA,EAAAA,QAGbT,QAAAA,WAAAA,EAAAA,QACAC,QAAAA,QAAAA,EAAAA","file":"index.map","sourceRoot":"../src","sourcesContent":["import debug from 'debug';\n\nexport default debug('paginated-listings-scraper');\n","import { URL } from 'url';\nimport Bluebird from 'bluebird';\nimport cheerio from 'cheerio';\nimport { isFunction, pickBy } from 'lodash'; // TODO get babel plugin for this\n\nimport debug from './debug';\n\n/**\n* @param  {string | Function} nextPageSelector\n* @param  {string} url\n* @param  {Function} $\n* @returns {Array}\n*/\n\nconst getNextPageUrl = function getNextPageUrl(nextPageSelector, $, url, depth) {\n  if (isFunction(nextPageSelector)) {\n    return nextPageSelector({ $, depth, url });\n  }\n\n  const element = $(nextPageSelector);\n  if (!element) {\n    debug(`getNextPageUrl - no element found for nextPageSelector ${nextPageSelector}`);\n    return null;\n  }\n\n  const href = element.attr('href');\n  if (!href) {\n    return null;\n  }\n\n  try {\n    const nextPageUrl = new URL(href).href;\n    debug(`getNextPageUrl - returned ${url}`);\n    return nextPageUrl;\n  } catch (error) {\n    const { origin } = new URL(url);\n    return `${origin}${href}`;\n  }\n};\n\n\nconst buildExtractText = selector => ({ $, parent }) => {\n  const element = parent ? parent.find(selector) : $(selector);\n  return element.text().trim();\n};\n\nexport const buildExtractData = selectors => async ({\n  parent,\n  html,\n  url,\n}) => {\n  try {\n    const data = await Bluebird.reduce(\n      Object.entries(selectors),\n      async (results, [key, selector]) => {\n        const extract = isFunction(selector) ? selector : buildExtractText(selector);\n        const $ = cheerio.load(html);\n        try {\n          const result = await extract({ $, parent, url });\n          return {\n            ...results,\n            [key]: result,\n          };\n        } catch (error) {\n          throw new Error(`${key} ${error.message}`);\n        }\n      }, {},\n    );\n    return pickBy(data);\n  } catch (error) {\n    debug(`Extraction error - ${error.message}`);\n    throw new Error(`Extraction error: ${url}\n      ${error.message}\n    `);\n  }\n};\n\n/**\n* @param  {Function} extract\n* @param  {Function} terminate\n* @returns {Function}\n*/\n\nconst withTerminate = (extract, terminate) => {\n  const state = { hasFinished: false, hasPrinted: false };\n  return async function extractWithTerminate({ html, parent, url }) {\n    const $ = cheerio.load(html);\n    state.hasFinished = terminate(parent, $);\n    if (state.hasFinished) {\n      if (!state.hasPrinted) {\n        debug('extractData - terminated');\n        state.hasPrinted = true;\n      }\n      return null;\n    }\n    const data = await extract({ html, parent, url });\n    return data;\n  };\n};\n\nconst buildDataSelectorExtractor = dataSelector => ({ html, ...rest }) => {\n  const $ = cheerio.load(html);\n  return dataSelector({ $, ...rest });\n};\n\n\n/**\n* @param  {Object} options\n* @param  {string | Function} options.dataSelector\n* @param  {Function} [options.filter]\n* @param  {string} options.html\n* @param  {string | Function} options.nextPageSelector\n* @param  {string} options.url\n* @param  {string} options.parentSelector\n* @param  {string | Function} [options.dataSelector]\n* @param  {Function} [options.terminate]\n* @returns {Array}\n*/\n\nexport const extractListingData = async function extractListingData({\n  dataSelector,\n  depth,\n  filter,\n  html,\n  nextPageSelector,\n  nextRequestOptions,\n  parentSelector,\n  terminate,\n  url,\n}) {\n  const $ = cheerio.load(html);\n  const elements = $(parentSelector).filter(!filter ? () => true : filter);\n\n  if (!elements.length) {\n    debug(`No elements found matching ${parentSelector}`);\n    return {\n      data: null,\n      nextPageUrl: getNextPageUrl(nextPageSelector, $, url, depth),\n      nextRequestOptions: nextRequestOptions && nextRequestOptions($, url, depth),\n    };\n  }\n  const extractor = isFunction(dataSelector)\n    ? buildDataSelectorExtractor(dataSelector)\n    : buildExtractData(dataSelector);\n\n  const extract = terminate ? withTerminate(extractor, terminate) : extractor;\n\n  const parents = elements.map((index, element) => $(element)).get();\n\n  const data = await Bluebird.map(parents, async (parent) => {\n    const extractedData = await extract({\n      html,\n      parent,\n      url,\n    });\n    return extractedData;\n  }).filter(Boolean);\n  // If the length of the data does not match the length of the elements acted on then we can assume\n  // that the terminate function returned true\n  const nextPageUrl = data.length === elements.length ? getNextPageUrl(\n    nextPageSelector,\n    $,\n    url,\n  ) : null;\n\n  return {\n    data,\n    nextPageUrl,\n    nextRequestOptions: nextRequestOptions && nextRequestOptions(url, $, depth),\n  };\n};\n","import request from 'request-promise-native';\nimport cheerio from 'cheerio';\n\nimport { buildExtractData } from './extract-data';\n\nexport const getPage = async (url, { loadCheerio, ...requestOptions } = {}) => {\n  try {\n    const { body: html, request: { uri: { href: resolvedUrl } } } = await request({\n      resolveWithFullResponse: true,\n      uri: url,\n      ...requestOptions,\n    });\n    if (loadCheerio) {\n      const $ = cheerio.load(html);\n      return { $, html, resolvedUrl };\n    }\n    return { html, resolvedUrl };\n  } catch (error) {\n    throw new Error(`Request error: ${url}\n      ${error.message}\n    `);\n  }\n};\n\nexport default async function scrapePage({\n  url,\n  selectors,\n  requestOptions,\n}) {\n  const { html, resolvedUrl, $ } = await getPage(url, { ...requestOptions, loadCheerio: true });\n  if (!html) {\n    throw new Error(`No HTML found: ${resolvedUrl}`);\n  }\n  const extractData = buildExtractData(selectors);\n  const extractedData = await extractData({\n    $,\n    html,\n    selectors,\n    url: resolvedUrl,\n  });\n\n  return extractedData;\n}\n","import { isNumber, isFunction } from 'lodash/fp';\n\nimport { getPage } from './scrape-page';\nimport { extractListingData } from './extract-data';\nimport debug from './debug';\n\n/**\n* Recursively calls its inner function to extract data from each page\n* @param  {Object} options\n* @param  {string} options.origin\n* @param  {number} [options.maximumDepth]\n* @param {Function} [options.terminate]\n* @returns {Function} getListing\n*/\n\nfunction getListings({\n  maximumDepth,\n  url,\n  shouldReturnDataOnError = false,\n  terminate,\n  ...otherOptions\n}) {\n  if (!isNumber(maximumDepth) && !isFunction(terminate)) {\n    throw Error('Please provide either a maximumDepth or a a terminate function');\n  }\n\n  const getListing = async (requestUrl, requestOptions, { depth = 1 } = {}) => {\n    if (isNumber(maximumDepth) && depth > maximumDepth) {\n      debug(`Maximum depth reached: ${depth}`);\n      return [];\n    }\n    debug(`Current page depth: ${depth}`);\n    try {\n      const { html } = await getPage(requestUrl, requestOptions);\n      const {\n        requestOptions: nextRequestOptions,\n        nextPageUrl,\n        data,\n      } = await extractListingData({ depth, html, terminate, url, ...otherOptions });\n\n      if (nextPageUrl || nextRequestOptions) {\n        const nextData = await getListing(nextPageUrl, nextRequestOptions, { depth: depth + 1 });\n        return [...data && data, ...nextData];\n      }\n      return data;\n    } catch (error) {\n      debug(`Error: ${error.message}`);\n      if (shouldReturnDataOnError) {\n        return [];\n      }\n      throw new Error(error);\n    }\n  };\n  return getListing;\n}\n\n\n/**\n* @param  {Object} options\n* @param  {string} options.url\n* @param  {Object} [options.requestOptions]\n* @returns {void}\n*/\n\nexport default async function scrapeListing(options) {\n  try {\n    const { url, requestOptions, ...otherOptions } = options;\n    const requestUrl = url || requestOptions.url;\n    const data = await getListings({ requestUrl, ...otherOptions })(requestUrl, requestOptions);\n    if (!data) {\n      debug('No data found');\n    } else {\n      debug(`Finished with ${data.length} results`);\n    }\n    return data;\n  } catch (error) {\n    debug(`Error: ${error.message}`);\n    throw new Error(error);\n  }\n}\n","import scrapeListing from './scrape-listing';\nimport scrapePage, { getPage } from './scrape-page';\n\nexport default scrapeListing;\n\nexport {\n  scrapePage,\n  getPage,\n};\n"]}